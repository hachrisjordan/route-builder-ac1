{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from 'react';\nimport dayjs from 'dayjs';\nimport routeDetails from '../../../data/route_details.json';\nexport default function useFlightDetails() {\n  _s();\n  const [selectedDates, setSelectedDates] = useState(null);\n  const [apiKey, setApiKey] = useState('');\n  const [segmentDetails, setSegmentDetails] = useState([]);\n  const [isLoadingSegments, setIsLoadingSegments] = useState(false);\n  const getSegmentDistance = (from, to) => {\n    const route = routeDetails.find(r => r.origin === from && r.destination === to);\n    if (!route) {\n      console.log(`Warning: No route found for ${from}-${to}, using default distance`);\n      return 1000;\n    }\n    console.log(`Distance for ${from}-${to}: ${route.distance.toLocaleString()} miles`);\n    return route.distance;\n  };\n  const processSegment = async (from, to, baseDate, timeWindow = null) => {\n    const API_URL = 'https://backend-284998006367.us-central1.run.app';\n    const dates = new Set([baseDate]);\n\n    // Add next day if time window extends to it\n    if (timeWindow !== null && timeWindow !== void 0 && timeWindow.latestDeparture) {\n      const nextDay = dayjs(baseDate).add(1, 'day').format('YYYY-MM-DD');\n      if (timeWindow.latestDeparture.isAfter(dayjs(nextDay))) {\n        dates.add(nextDay);\n      }\n    }\n    const flights = [];\n    let earliestArrival = null;\n    let latestArrival = null;\n    console.log(`Processing route ${from}-${to}:`);\n\n    // Process each date\n    for (const date of dates) {\n      const route = routeDetails.find(r => r.origin === from && r.destination === to && r.date === date);\n      if (route) {\n        console.log(`  Found segment ID ${route.ID} for date ${date}`);\n        try {\n          var _data$results, _data$results$, _data$results$$data;\n          const response = await fetch(`${API_URL}/api/seats/${route.ID}`, {\n            method: 'GET',\n            headers: {\n              'accept': 'application/json',\n              'Partner-Authorization': apiKey,\n              'Segment-ID': route.ID\n            }\n          });\n          if (!response.ok) {\n            console.log(`  Failed to fetch segment ${route.ID}: ${response.status}`);\n            continue;\n          }\n          const data = await response.json();\n          if ((_data$results = data.results) !== null && _data$results !== void 0 && (_data$results$ = _data$results[0]) !== null && _data$results$ !== void 0 && (_data$results$$data = _data$results$.data) !== null && _data$results$$data !== void 0 && _data$results$$data.data) {\n            data.results[0].data.data.forEach(trip => {\n              const departureTime = dayjs(trip.DepartsAt.replace('Z', ''));\n              const arrivalTime = dayjs(trip.ArrivesAt.replace('Z', ''));\n              const baseDayjs = dayjs(baseDate);\n\n              // Skip if outside time window\n              if (timeWindow) {\n                if (departureTime.isBefore(timeWindow.earliestDeparture) || departureTime.isAfter(timeWindow.latestDeparture)) {\n                  return;\n                }\n              }\n\n              // Calculate day differences\n              const departDayDiff = departureTime.diff(baseDayjs, 'day');\n              const arrivalDayDiff = arrivalTime.diff(baseDayjs, 'day');\n              const flight = {\n                from,\n                to,\n                flightNumber: trip.FlightNumber,\n                airlines: trip.Carriers[0],\n                aircraft: trip.Aircraft[0],\n                departs: departDayDiff > 0 ? `${departureTime.format('HH:mm')} (+${departDayDiff})` : departureTime.format('HH:mm'),\n                arrives: arrivalDayDiff > 0 ? `${arrivalTime.format('HH:mm')} (+${arrivalDayDiff})` : arrivalTime.format('HH:mm'),\n                DepartsAt: trip.DepartsAt.replace('Z', ''),\n                ArrivesAt: trip.ArrivesAt.replace('Z', ''),\n                economy: trip.Cabin.toLowerCase() === 'economy',\n                business: trip.Cabin.toLowerCase() === 'business',\n                first: trip.Cabin.toLowerCase() === 'first'\n              };\n              flights.push(flight);\n\n              // Update arrival bounds\n              if (!earliestArrival || arrivalTime.isBefore(earliestArrival)) {\n                earliestArrival = arrivalTime;\n              }\n              if (!latestArrival || arrivalTime.isAfter(latestArrival)) {\n                latestArrival = arrivalTime;\n              }\n            });\n          }\n        } catch (error) {\n          console.error(`  Error processing segment ${route.ID}:`, error);\n        }\n      }\n    }\n    return {\n      flights: flights.sort((a, b) => {\n        // Sort by departure time\n        const aTime = dayjs(a.DepartsAt);\n        const bTime = dayjs(b.DepartsAt);\n        return aTime.diff(bTime);\n      }),\n      earliestArrival,\n      latestArrival\n    };\n  };\n  const handleDateSearch = async currentRoute => {\n    if (!selectedDates || !currentRoute || !apiKey) return;\n    setIsLoadingSegments(true);\n    const processedSegments = [];\n    const baseDate = selectedDates.format('YYYY-MM-DD');\n    try {\n      // Process each segment\n      for (let i = 0; i < currentRoute.length - 1; i++) {\n        const from = currentRoute[i];\n        const to = currentRoute[i + 1];\n        const prevSegment = processedSegments[i - 1];\n        let timeWindow = null;\n        if (prevSegment) {\n          const prevFrom = currentRoute[i - 1];\n          const prevTo = currentRoute[i];\n          const prevDistance = getSegmentDistance(prevFrom, prevTo);\n          const minConnectionHours = Math.ceil(prevDistance / 575);\n          if (prevSegment.flights.length === 0) {\n            const baseTime = prevSegment.earliestArrival || dayjs(baseDate);\n            const endTime = prevSegment.latestArrival || baseTime;\n            timeWindow = {\n              earliestDeparture: baseTime.add(minConnectionHours, 'hour'),\n              latestDeparture: endTime.add(24, 'hour').add(minConnectionHours, 'hour')\n            };\n          } else {\n            timeWindow = {\n              earliestDeparture: prevSegment.earliestArrival.add(minConnectionHours, 'hour'),\n              latestDeparture: prevSegment.latestArrival.add(24, 'hour')\n            };\n          }\n        }\n        const segment = await processSegment(from, to, baseDate, timeWindow);\n        processedSegments.push(segment);\n      }\n\n      // Flatten all segments into a single array\n      setSegmentDetails(processedSegments.flatMap(segment => segment.flights));\n    } catch (error) {\n      console.error('Error fetching segment details:', error);\n    } finally {\n      setIsLoadingSegments(false);\n    }\n  };\n  const resetDetails = () => {\n    setSelectedDates(null);\n    setApiKey('');\n    setSegmentDetails([]);\n  };\n  return {\n    selectedDates,\n    setSelectedDates,\n    apiKey,\n    setApiKey,\n    segmentDetails,\n    isLoadingSegments,\n    handleDateSearch,\n    resetDetails\n  };\n}\n_s(useFlightDetails, \"eNL6x3p2kS9/dPwFDvdCZanJHcQ=\");","map":{"version":3,"names":["useState","dayjs","routeDetails","useFlightDetails","_s","selectedDates","setSelectedDates","apiKey","setApiKey","segmentDetails","setSegmentDetails","isLoadingSegments","setIsLoadingSegments","getSegmentDistance","from","to","route","find","r","origin","destination","console","log","distance","toLocaleString","processSegment","baseDate","timeWindow","API_URL","dates","Set","latestDeparture","nextDay","add","format","isAfter","flights","earliestArrival","latestArrival","date","ID","_data$results","_data$results$","_data$results$$data","response","fetch","method","headers","ok","status","data","json","results","forEach","trip","departureTime","DepartsAt","replace","arrivalTime","ArrivesAt","baseDayjs","isBefore","earliestDeparture","departDayDiff","diff","arrivalDayDiff","flight","flightNumber","FlightNumber","airlines","Carriers","aircraft","Aircraft","departs","arrives","economy","Cabin","toLowerCase","business","first","push","error","sort","a","b","aTime","bTime","handleDateSearch","currentRoute","processedSegments","i","length","prevSegment","prevFrom","prevTo","prevDistance","minConnectionHours","Math","ceil","baseTime","endTime","segment","flatMap","resetDetails"],"sources":["C:/Users/nguyen77/docker-neo4j/route-builder-ac1/src/components/FlightSearch/hooks/useFlightDetails.js"],"sourcesContent":["import { useState } from 'react';\r\nimport dayjs from 'dayjs';\r\nimport routeDetails from '../../../data/route_details.json';\r\n\r\nexport default function useFlightDetails() {\r\n  const [selectedDates, setSelectedDates] = useState(null);\r\n  const [apiKey, setApiKey] = useState('');\r\n  const [segmentDetails, setSegmentDetails] = useState([]);\r\n  const [isLoadingSegments, setIsLoadingSegments] = useState(false);\r\n\r\n  const getSegmentDistance = (from, to) => {\r\n    const route = routeDetails.find(r => \r\n      r.origin === from && \r\n      r.destination === to\r\n    );\r\n\r\n    if (!route) {\r\n      console.log(`Warning: No route found for ${from}-${to}, using default distance`);\r\n      return 1000;\r\n    }\r\n\r\n    console.log(`Distance for ${from}-${to}: ${route.distance.toLocaleString()} miles`);\r\n    return route.distance;\r\n  };\r\n\r\n  const processSegment = async (from, to, baseDate, timeWindow = null) => {\r\n    const API_URL = 'https://backend-284998006367.us-central1.run.app';\r\n    const dates = new Set([baseDate]);\r\n    \r\n    // Add next day if time window extends to it\r\n    if (timeWindow?.latestDeparture) {\r\n      const nextDay = dayjs(baseDate).add(1, 'day').format('YYYY-MM-DD');\r\n      if (timeWindow.latestDeparture.isAfter(dayjs(nextDay))) {\r\n        dates.add(nextDay);\r\n      }\r\n    }\r\n\r\n    const flights = [];\r\n    let earliestArrival = null;\r\n    let latestArrival = null;\r\n\r\n    console.log(`Processing route ${from}-${to}:`);\r\n    \r\n    // Process each date\r\n    for (const date of dates) {\r\n      const route = routeDetails.find(r => \r\n        r.origin === from && \r\n        r.destination === to && \r\n        r.date === date\r\n      );\r\n      \r\n      if (route) {\r\n        console.log(`  Found segment ID ${route.ID} for date ${date}`);\r\n        try {\r\n          const response = await fetch(`${API_URL}/api/seats/${route.ID}`, {\r\n            method: 'GET',\r\n            headers: {\r\n              'accept': 'application/json',\r\n              'Partner-Authorization': apiKey,\r\n              'Segment-ID': route.ID\r\n            }\r\n          });\r\n\r\n          if (!response.ok) {\r\n            console.log(`  Failed to fetch segment ${route.ID}: ${response.status}`);\r\n            continue;\r\n          }\r\n\r\n          const data = await response.json();\r\n          \r\n          if (data.results?.[0]?.data?.data) {\r\n            data.results[0].data.data.forEach(trip => {\r\n              const departureTime = dayjs(trip.DepartsAt.replace('Z', ''));\r\n              const arrivalTime = dayjs(trip.ArrivesAt.replace('Z', ''));\r\n              const baseDayjs = dayjs(baseDate);\r\n              \r\n              // Skip if outside time window\r\n              if (timeWindow) {\r\n                if (departureTime.isBefore(timeWindow.earliestDeparture) || \r\n                    departureTime.isAfter(timeWindow.latestDeparture)) {\r\n                  return;\r\n                }\r\n              }\r\n\r\n              // Calculate day differences\r\n              const departDayDiff = departureTime.diff(baseDayjs, 'day');\r\n              const arrivalDayDiff = arrivalTime.diff(baseDayjs, 'day');\r\n\r\n              const flight = {\r\n                from,\r\n                to,\r\n                flightNumber: trip.FlightNumber,\r\n                airlines: trip.Carriers[0],\r\n                aircraft: trip.Aircraft[0],\r\n                departs: departDayDiff > 0 ? \r\n                  `${departureTime.format('HH:mm')} (+${departDayDiff})` : \r\n                  departureTime.format('HH:mm'),\r\n                arrives: arrivalDayDiff > 0 ? \r\n                  `${arrivalTime.format('HH:mm')} (+${arrivalDayDiff})` : \r\n                  arrivalTime.format('HH:mm'),\r\n                DepartsAt: trip.DepartsAt.replace('Z', ''),\r\n                ArrivesAt: trip.ArrivesAt.replace('Z', ''),\r\n                economy: trip.Cabin.toLowerCase() === 'economy',\r\n                business: trip.Cabin.toLowerCase() === 'business',\r\n                first: trip.Cabin.toLowerCase() === 'first'\r\n              };\r\n\r\n              flights.push(flight);\r\n\r\n              // Update arrival bounds\r\n              if (!earliestArrival || arrivalTime.isBefore(earliestArrival)) {\r\n                earliestArrival = arrivalTime;\r\n              }\r\n              if (!latestArrival || arrivalTime.isAfter(latestArrival)) {\r\n                latestArrival = arrivalTime;\r\n              }\r\n            });\r\n          }\r\n        } catch (error) {\r\n          console.error(`  Error processing segment ${route.ID}:`, error);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      flights: flights.sort((a, b) => {\r\n        // Sort by departure time\r\n        const aTime = dayjs(a.DepartsAt);\r\n        const bTime = dayjs(b.DepartsAt);\r\n        return aTime.diff(bTime);\r\n      }),\r\n      earliestArrival,\r\n      latestArrival\r\n    };\r\n  };\r\n\r\n  const handleDateSearch = async (currentRoute) => {\r\n    if (!selectedDates || !currentRoute || !apiKey) return;\r\n    \r\n    setIsLoadingSegments(true);\r\n    const processedSegments = [];\r\n    const baseDate = selectedDates.format('YYYY-MM-DD');\r\n    \r\n    try {\r\n      // Process each segment\r\n      for (let i = 0; i < currentRoute.length - 1; i++) {\r\n        const from = currentRoute[i];\r\n        const to = currentRoute[i + 1];\r\n        const prevSegment = processedSegments[i - 1];\r\n        \r\n        let timeWindow = null;\r\n        if (prevSegment) {\r\n          const prevFrom = currentRoute[i - 1];\r\n          const prevTo = currentRoute[i];\r\n          const prevDistance = getSegmentDistance(prevFrom, prevTo);\r\n          const minConnectionHours = Math.ceil(prevDistance / 575);\r\n          \r\n          if (prevSegment.flights.length === 0) {\r\n            const baseTime = prevSegment.earliestArrival || dayjs(baseDate);\r\n            const endTime = prevSegment.latestArrival || baseTime;\r\n            \r\n            timeWindow = {\r\n              earliestDeparture: baseTime.add(minConnectionHours, 'hour'),\r\n              latestDeparture: endTime.add(24, 'hour').add(minConnectionHours, 'hour')\r\n            };\r\n          } else {\r\n            timeWindow = {\r\n              earliestDeparture: prevSegment.earliestArrival.add(minConnectionHours, 'hour'),\r\n              latestDeparture: prevSegment.latestArrival.add(24, 'hour')\r\n            };\r\n          }\r\n        }\r\n\r\n        const segment = await processSegment(from, to, baseDate, timeWindow);\r\n        processedSegments.push(segment);\r\n      }\r\n\r\n      // Flatten all segments into a single array\r\n      setSegmentDetails(processedSegments.flatMap(segment => segment.flights));\r\n    } catch (error) {\r\n      console.error('Error fetching segment details:', error);\r\n    } finally {\r\n      setIsLoadingSegments(false);\r\n    }\r\n  };\r\n\r\n  const resetDetails = () => {\r\n    setSelectedDates(null);\r\n    setApiKey('');\r\n    setSegmentDetails([]);\r\n  };\r\n\r\n  return {\r\n    selectedDates,\r\n    setSelectedDates,\r\n    apiKey,\r\n    setApiKey,\r\n    segmentDetails,\r\n    isLoadingSegments,\r\n    handleDateSearch,\r\n    resetDetails\r\n  };\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}